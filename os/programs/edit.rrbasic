REM globals
max = 100
lines = 0
top = 0
currentx = 0
currenty = 0
dirty = FALSE
hl_on = TRUE
DIM content$, max
lastfind$ = ""

lastrepl$ = ""
hit_line = 0
hit_pos = 0

AUTOFLIP FALSE

REM load file, draw UI, start editor input loop
PROCload(ARGS$)
IF ARGS$ = "" THEN lines = 1
CLS
PROCtext
PROCedit
END

REM clear line from cursor to right
DEF PROCclearLineFromCursor
	PRINT CHR$(27) + "[0K";
ENDPROC

REM draw UI around editor window
DEF PROCdraw
	BACKGROUND 1
	COLOUR 15
	CURSOR 1, TERMHEIGHT
	PROCclearLineFromCursor
	CURSOR 2, TERMHEIGHT
	GCOL &AA
    RECTANGLE 0, GRAPHICS_HEIGHT - 20, GRAPHICS_WIDTH - 1, GRAPHICS_HEIGHT - 1
	PRINT "ESC EXIT", CHR$(9), "^S SAVE", CHR$(9), "^W WHEREIS", CHR$(9), "^R REPLACE", CHR$(9), "^T ";
	IF hl_on = TRUE THEN
	    PRINT "DISABLE SYNTAX";
	ELSE
	    PRINT "ENABLE SYNTAX";
	ENDIF
	CURSOR TERMWIDTH - 15, TERMHEIGHT
	PRINT currentx; ","; top + currenty; " ";
	CURSOR 1, 0
	PROCclearLineFromCursor
	RECTANGLE 0, 0, GRAPHICS_WIDTH - 1, 20
	CURSOR TERMWIDTH / 2 - 2, 0
	PRINT "EDIT";
	COLOUR 7
	BACKGROUND 0
	CURSOR 1, 2
ENDPROC

REM Display prompt in bottom section of screen
DEF PROCprompt(prompt$)
	PROCdraw
	BACKGROUND 1
	COLOUR 15
	CURSOR 1, TERMHEIGHT
	PROCclearLineFromCursor
	CURSOR 2, TERMHEIGHT
	PRINT prompt$; ": ";
	AUTOFLIP FALSE
	FLIP
ENDPROC

REM clear prompt
DEF PROCendPrompt
	CLS
	PROCtext
ENDPROC

REM hide text cursor
DEF PROChideCursor
	PRINT CHR$(27);"[?25l";
ENDPROC

REM show text cursor
DEF PROCshowCursor
	PRINT CHR$(27);"[?25h";
ENDPROC

REM display text to editor window
DEF PROCtext
	PROChideCursor
	PROCdraw
	CURSOR 1, 2
	FOR l = top TO top + TERMHEIGHT - 3
		PROCclearLineFromCursor
		IF l < max THEN
		    IF hl_on = TRUE THEN PRINT HIGHLIGHT$(LEFT$(content$(l), TERMWIDTH))
		    IF hl_on = FALSE THEN PRINT LEFT$(content$(l), TERMWIDTH)
		ENDIF
	NEXT
	AUTOFLIP FALSE
	FLIP
	PROCshowCursor
ENDPROC

REM load a file into the array, translating TAB to four spaces
DEF PROCload(file$)
	IF file$ = "" THEN ENDPROC
	FH = OPENIN(file$)
	IF FH < 0 THEN PROCfail
	lines = 0
	REPEAT
		content$(lines) = REPLACE$(READ$(FH), CHR$(9), "    ")
		lines = lines + 1
		IF lines = max THEN
		    PROCgrow
		    PRINT ".";
		    FLIP
		ENDIF
	UNTIL EOF(FH) = 1
	PRINT ""
	CLOSE FH
ENDPROC

REM increase array used to store text
DEF PROCgrow
	max = max + 100
	REDIM content$, max
ENDPROC

REM error handler
DEF PROCfail
	PRINT "Could not open file: "; ARGS$
	END
ENDPROC

REM handle editor input loop
DEF PROCedit
	REPEAT
		CURSOR currentx + 1, currenty + 2
    	AUTOFLIP FALSE
		FLIP
		KGET key$
		PROCprocessKey(ASC(key$))
	UNTIL FALSE
ENDPROC

REM handle keypress
DEF PROCprocessKey(in)
	incopy = in
	ctrl = CTRLKEY
	IF ctrl = TRUE THEN PROCctrl(CHR$(incopy))
	IF ctrl = TRUE THEN ENDPROC
	IF in = 27 THEN PROCquit
	IF in = 13 THEN PROCenter
	IF in = 250 THEN PROCup
	IF in = 251 THEN PROCdown
	IF in = 252 THEN PROCleft
	IF in = 253 THEN PROCright
	IF in = 249 THEN PROCend
	IF in = 254 THEN PROChome
	IF in = 245 THEN PROCpageUp
	IF in = 246 THEN PROCpageDown
	IF in = 247 THEN PROCdelete
	IF in = 8 THEN PROCbackSpace
	IF (in < 128) AND (in > 31) THEN PROCinsertChar(incopy)
	cx = LEN(content$(top + currenty))
	IF currentx > cx THEN currentx = cx
	IF (currenty + top) > (lines - 1) THEN currenty = lines - top - 1
ENDPROC

REM insert character at current position and advance right
DEF PROCinsertChar(i)
	start$ = MID$(content$(top + currenty), 0, currentx)
	end$ = MID$(content$(top + currenty), currentx, LEN(content$(top + currenty)))
	content$(top + currenty) = start$ + CHR$(i) + end$
	currentx = currentx + 1
	dirty = TRUE
	PROCtext
ENDPROC

REM handle CTRL+key
DEF PROCctrl(ctrlkey$)
	IF UPPER$(ctrlkey$) = "S" THEN PROCsave
	IF UPPER$(ctrlkey$) = "W" THEN PROCsearch
	IF UPPER$(ctrlkey$) = "R" THEN PROCreplace
	IF UPPER$(ctrlkey$) = "T" THEN PROCtoggleSyntax
	PROCtext
ENDPROC

REM Toggle syntax highlighting
DEF PROCtoggleSyntax
    IF hl_on = TRUE THEN
        hl_on = FALSE
    ELSE
        hl_on = TRUE
    ENDIF
ENDPROC

REM handle save
DEF PROCsave
	IF ARGS$ = "" THEN PROCsaveNew
	IF ARGS$ = "" THEN ENDPROC
	PROCsaveAs
ENDPROC

REM handle save over existing file
DEF PROCsaveAs
	PROCprompt("Save as [" + ARGS$ + "]")
	AUTOFLIP TRUE
	INPUT file$
	AUTOFLIP FALSE
	IF file$ = "" THEN file$ = ARGS$
	PROCdoSave(file$)
ENDPROC

REM handle save to new file
DEF PROCsaveNew
	PROCprompt("Save as")
	AUTOFLIP TRUE
	INPUT file$
	AUTOFLIP FALSE
	PROCdoSave(file$)
ENDPROC

REM save file
DEF PROCdoSave(saveFileName$)
	FH = OPENOUT(saveFileName$)
	IF FH < 0 THEN PROCsaveError(saveFileName$)
	IF FH < 0 THEN ENDPROC
	REM write file line by line
	FOR X = 0 TO lines - 1
		WRITE FH, content$(X)
	NEXT
	CLOSE FH
	dirty = FALSE
ENDPROC

REM display save error
DEF PROCsaveError
	PROCprompt("Unable to save file! Press any key to continue")
	KGET dummy$
ENDPROC

DEF PROCsearch
	PROCprompt("Search text")
	AUTOFLIP TRUE
	INPUT find$
	AUTOFLIP FALSE
	IF find$ <> "" THEN lastfind$ = find$
	IF lastfind$ = "" THEN
		PROCendPrompt
		ENDPROC
	ENDIF
	PROCdoFind(lastfind$)
ENDPROC

REM forward find from cursor, wraps once
DEF PROCdoFind(needle$)
	start_line = top + currenty
	start_col = currentx + 1

	IF FNscanFrom(start_line, start_col, needle$) = TRUE THEN
	    PROCendPrompt
	    ENDPROC
	ENDIF

	IF FNscanFrom(0, 0, needle$) = TRUE THEN
	    PROCendPrompt
	    ENDPROC
	ENDIF

    PROCtext
	PROCprompt("Not found. Press any key")
	KGET dummy$
	PROCendPrompt
ENDPROC

REM scan lines using INSTR; positions are 1-based
DEF FNscanFrom(line_from, col_from, needle$)
	FOR L = line_from TO lines - 1
		hay$ = content$(L)
		pos = INSTR(hay$, needle$)
		IF pos > 0 THEN
		    PROCmoveCursorToHit(L, pos - 1)
            =TRUE
        ENDIF
	NEXT
=FALSE

REM place cursor on L,pos and bring into view
DEF PROCmoveCursorToHit(L, pos)
	REM set top so that L is visible
	win_top = top
	win_bot = top + TERMHEIGHT - 3
	IF L < win_top THEN top = L
	IF L > win_bot THEN top = L - (TERMHEIGHT - 3)
	IF top < 0 THEN top = 0
	currenty = L - top
	currentx = pos
	IF currentx > (TERMWIDTH - 1) THEN currentx = TERMWIDTH - 1
    PROCtext
	PROCprompt("Replace this occurrence? (Y)es/(N)o/(A)ll/(Q)uit")
    CURSOR currentx + 1, currenty + 2
ENDPROC

REM handle escape key
DEF PROCquit
	IF dirty = TRUE THEN PROCconfirm
	IF dirty = TRUE THEN ENDPROC
	CLS
	END
ENDPROC

REM confirm exit if file contents changed
DEF PROCconfirm
	PROCprompt("Contents changed. Are you sure?")
	KGET input$
	PROCtext
	IF UPPER$(input$) = "N" THEN ENDPROC
	CLS
	END
ENDPROC

REM handle cursor left key
DEF PROCleft
	currentx = currentx - 1
	IF currentx < 0 THEN currentx = 0
	PROCtext
ENDPROC

REM handle cursor up key
DEF PROCup
	currenty = currenty - 1
	IF currenty < 0 THEN PROCscrollUp
	PROCtext
ENDPROC

REM handle cursor down key
DEF PROCdown
	currenty = currenty + 1
	IF currenty > (TERMHEIGHT - 3) THEN PROCscrollDown
	PROCtext
ENDPROC

REM scroll screen down one line
DEF PROCscrollDown
	currenty = TERMHEIGHT - 3
	top = top + 1
	IF top > (TERMHEIGHT - 2 + lines) THEN top = TERMHEIGHT - 2 + lines
	PROCtext
ENDPROC

REM Scroll screen up one line
DEF PROCscrollUp
	currenty = 0
	top = top - 1
	IF top < 0 THEN top = 0
ENDPROC

REM handle cursor right key
DEF PROCright
	currentx = currentx + 1
	IF currentx > (TERMWIDTH - 1) THEN currentx = TERMWIDTH - 1
	PROCtext
ENDPROC

REM handle end key
DEF PROCend
	currentx = LEN(content$(top + currenty))
	IF currentx > (TERMWIDTH - 1) THEN currentx = TERMWIDTH - 1
	PROCtext
ENDPROC

REM handle home key
DEF PROChome
	currentx = 0
	PROCtext
ENDPROC

REM handle page up key
DEF PROCpageUp
	top = top - TERMHEIGHT - 2
	IF top < 0 THEN top = 0
	PROCtext
ENDPROC

REM handle page down key
DEF PROCpageDown
	IF (top + currenty + TERMHEIGHT - 2) > (lines - 1) THEN ENDPROC
	top = top + TERMHEIGHT - 2
	IF top > (TERMHEIGHT - 2 + lines) THEN top = TERMHEIGHT - 2 + lines
	PROCtext
ENDPROC

REM handle enter key, split line if neccessary
DEF PROCenter
	currentLine$ = content$(top + currenty)
	start$ = MID$(currentLine$, 0, currentx)
	end$ = MID$(currentLine$, currentx, LEN(currentLine$))
	REM push lines below down
	PUSH content$, top + currenty
	content$(top + currenty) = start$
	content$(top + currenty + 1) = end$
	currentx = 0
	currenty = currenty + 1
	lines = lines + 1
	IF lines = max THEN PROCgrow
	IF currenty > (TERMHEIGHT - 3) THEN PROCscrollDown
	dirty = TRUE
	PROCtext
ENDPROC

REM handle delete key, join line if neccessary
DEF PROCdelete
	currentLine$ = content$(top + currenty)
	len = LEN(currentLine$)
	IF currentx > (len - 1) THEN PROCjoin
	IF currentx < len THEN PROCdeleteRight
	dirty = TRUE
	PROCtext
ENDPROC

REM handle backspace
DEF PROCbackSpace
	cx = currentx
	IF cx = 0 THEN PROCjoinAbove
	IF cx > 0 THEN PROCdeleteLeft
	dirty = TRUE
	PROCtext
ENDPROC

REM delete character to left of cursor, advance left
DEF PROCdeleteLeft
	start$ = MID$(content$(top + currenty), 0, currentx - 1)
	end$ = MID$(content$(top + currenty), currentx, LEN(content$(top + currenty)))
	content$(top + currenty) = start$ + end$
	currentx = currentx - 1
ENDPROC

REM delete one character to the right
DEF PROCdeleteRight
	start$ = MID$(content$(top + currenty), 0, currentx)
	end$ = MID$(content$(top + currenty), currentx + 1, LEN(content$(top + currenty)))
	content$(top + currenty) = start$ + end$
ENDPROC

REM join the end of the current line to the line below, moving lines up
DEF PROCjoin
	IF currenty = (lines - 1) THEN ENDPROC
	content$(top + currenty) = content$(top + currenty) + content$(top + currenty + 1)
	POP content$, top + currenty + 1
	content$(lines - 1) = ""
	lines = lines - 1
ENDPROC

REM join the start of the current line to the line above, moving lines up
DEF PROCjoinAbove
	IF currenty = 0 THEN ENDPROC
	newcurrentx = LEN(content$(top + currenty - 1))
	content$(top + currenty - 1) = content$(top + currenty - 1) + content$(top + currenty)
	POP content$, top + currenty
	content$(lines - 1) = ""
	currentx = newcurrentx
	currenty = currenty - 1
	lines = lines - 1
ENDPROC

REM ----------------------------

REM search and replace (interactive)
DEF PROCreplace
	PROCprompt("Search text")
	AUTOFLIP TRUE
	INPUT find$
	AUTOFLIP FALSE
	IF find$ <> "" THEN lastfind$ = find$
	IF lastfind$ = "" THEN
		PROCendPrompt
 		ENDPROC
	ENDIF
	PROCendPrompt
	PROCprompt("Replace with")
	AUTOFLIP TRUE
	INPUT repl$
	AUTOFLIP FALSE
	IF repl$ <> "" THEN lastrepl$ = repl$
	PROCendPrompt
	PROCreplaceLoop(lastfind$, lastrepl$)
ENDPROC

REM interactive replace loop with Y/N/A/Q controls; wraps once
DEF PROCreplaceLoop(find$, repl$)
	all_mode = FALSE
	did_wrap = FALSE
	exit_replace = FALSE
	next_line = top + currenty
	next_col = currentx + 1
	uk$ = ""
	PROCdraw
	REPEAT
		IF FNnextHit(next_line, next_col, find$) = FALSE THEN
			IF did_wrap = FALSE THEN
				did_wrap = TRUE
				next_line = 0
				next_col = 0
			ELSE
			    PROCtext
			    exit_replace = TRUE
			ENDIF
		ELSE
			IF all_mode = TRUE THEN
				PROCreplaceAtHit(find$, repl$)
				dirty = TRUE
				next_line = hit_line
				next_col = hit_pos + LEN(repl$)
			ELSE
    			PROCmoveCursorToHit(hit_line, hit_pos)
				KGET k$
				PROCendPrompt
				uk$ = UPPER$(k$)
				IF uk$ = "Y" THEN
					PROCreplaceAtHit(find$, repl$)
					dirty = TRUE
					next_line = hit_line
					next_col = hit_pos + LEN(repl$)
				ENDIF
				IF uk$ = "N" THEN
					next_line = hit_line
					next_col = hit_pos + 1
				ENDIF
				IF uk$ = "A" THEN
					all_mode = TRUE
					PROCreplaceAtHit(find$, repl$)
					dirty = TRUE
					next_line = hit_line
					next_col = hit_pos + LEN(repl$)
				ENDIF
				IF uk$ = "Q" THEN
				    PROCtext
                    exit_replace = TRUE
                ENDIF
				IF uk$ <> "Q" AND uk$ <> "A" AND uk$ <> "N" AND uk$ <> "Y" THEN
					next_line = hit_line
					next_col = hit_pos
				ENDIF
			ENDIF
		ENDIF
	UNTIL exit_replace = TRUE
	PROCtext
ENDPROC

REM replace the current hit with repl$, update cursor and window
DEF PROCreplaceAtHit(find$, repl$)
	hay$ = content$(hit_line)
	start$ = MID$(hay$, 0, hit_pos)
	end$ = MID$(hay$, hit_pos + LEN(find$), LEN(hay$))
	content$(hit_line) = start$ + repl$ + end$

	REM place cursor just after the replaced text
	new_pos = LEN(start$) + LEN(repl$)
	currentx = new_pos
	IF currentx > (TERMWIDTH - 1) THEN currentx = TERMWIDTH - 1

	PROCmoveCursorToHit(hit_line, currentx)
ENDPROC

REM find next hit from (line_from,col_from); sets hit_line/hit_pos; TRUE if found
DEF FNnextHit(line_from, col_from, needle$)
	FOR L = line_from TO lines - 1
		hay$ = content$(L)
		IF L = line_from THEN
			search_from = col_from
		ELSE
			search_from = 0
		ENDIF
		sub$ = MID$(hay$, search_from, LEN(hay$))
		pos_rel = INSTR(sub$, needle$)
		IF pos_rel > 0 THEN
			hit_line = L
			hit_pos = search_from + pos_rel - 1
			=TRUE
		ENDIF
	NEXT
=FALSE

