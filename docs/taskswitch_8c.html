<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Retro Rocket Kernel: taskswitch.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Retro Rocket Kernel
   </div>
   <div id="projectbrief">BASIC-Powered Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('taskswitch_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">taskswitch.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="kernel_8h.html">kernel.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa489f46acde8e80831f0432a1da6e695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#aa489f46acde8e80831f0432a1da6e695">proc_load</a> (const char *fullpath, struct <a class="el" href="structconsole.html">console</a> *cons, <a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a> parent_pid, const char *csd)</td></tr>
<tr class="memdesc:aa489f46acde8e80831f0432a1da6e695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and start a new BASIC process.  <a href="taskswitch_8c.html#aa489f46acde8e80831f0432a1da6e695">More...</a><br /></td></tr>
<tr class="separator:aa489f46acde8e80831f0432a1da6e695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8769acde79d259426e68e9e4fba6544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#aa8769acde79d259426e68e9e4fba6544">proc_cur</a> (uint8_t logical_cpu)</td></tr>
<tr class="memdesc:aa8769acde79d259426e68e9e4fba6544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current process for a logical CPU.  <a href="taskswitch_8c.html#aa8769acde79d259426e68e9e4fba6544">More...</a><br /></td></tr>
<tr class="separator:aa8769acde79d259426e68e9e4fba6544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb94173794194e3382dc5482b7e0aa62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#abb94173794194e3382dc5482b7e0aa62">proc_run</a> (<a class="el" href="structprocess__t.html">process_t</a> *proc)</td></tr>
<tr class="memdesc:abb94173794194e3382dc5482b7e0aa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute one atomic BASIC cycle for a process.  <a href="taskswitch_8c.html#abb94173794194e3382dc5482b7e0aa62">More...</a><br /></td></tr>
<tr class="separator:abb94173794194e3382dc5482b7e0aa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a40192ac7fb47cf38c7e803ccd0efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#ab5a40192ac7fb47cf38c7e803ccd0efb">proc_find</a> (<a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a> pid)</td></tr>
<tr class="memdesc:ab5a40192ac7fb47cf38c7e803ccd0efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a process by PID.  <a href="taskswitch_8c.html#ab5a40192ac7fb47cf38c7e803ccd0efb">More...</a><br /></td></tr>
<tr class="separator:ab5a40192ac7fb47cf38c7e803ccd0efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b25ff76590322d996a0cb108665cedc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a7b25ff76590322d996a0cb108665cedc">proc_kill_id</a> (<a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a> <a class="el" href="dns_8c.html#a4fc3a0c58dfbd1e68224521185cb9384">id</a>)</td></tr>
<tr class="memdesc:a7b25ff76590322d996a0cb108665cedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill a process by PID.  <a href="taskswitch_8c.html#a7b25ff76590322d996a0cb108665cedc">More...</a><br /></td></tr>
<tr class="separator:a7b25ff76590322d996a0cb108665cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2b24e480bc2b9188e720c028795cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a8b2b24e480bc2b9188e720c028795cee">proc_wait</a> (<a class="el" href="structprocess__t.html">process_t</a> *proc, <a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a> otherpid)</td></tr>
<tr class="memdesc:a8b2b24e480bc2b9188e720c028795cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a process as waiting for another to complete.  <a href="taskswitch_8c.html#a8b2b24e480bc2b9188e720c028795cee">More...</a><br /></td></tr>
<tr class="separator:a8b2b24e480bc2b9188e720c028795cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0340f929d97ebceb2e0d7eaa9d4d3ff"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#aa0340f929d97ebceb2e0d7eaa9d4d3ff">proc_set_csd</a> (<a class="el" href="structprocess__t.html">process_t</a> *proc, const char *csd)</td></tr>
<tr class="memdesc:aa0340f929d97ebceb2e0d7eaa9d4d3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the CSD (current selected directory) of a process.  <a href="taskswitch_8c.html#aa0340f929d97ebceb2e0d7eaa9d4d3ff">More...</a><br /></td></tr>
<tr class="separator:aa0340f929d97ebceb2e0d7eaa9d4d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949bb14b82e340cdc2a49f9ecc53b086"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a949bb14b82e340cdc2a49f9ecc53b086">proc_get_csd</a> (<a class="el" href="structprocess__t.html">process_t</a> *proc)</td></tr>
<tr class="separator:a949bb14b82e340cdc2a49f9ecc53b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8951b9dab6452cf831a751d0cda64a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a8951b9dab6452cf831a751d0cda64a5d">proc_kill</a> (<a class="el" href="structprocess__t.html">process_t</a> *proc)</td></tr>
<tr class="memdesc:a8951b9dab6452cf831a751d0cda64a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill a process immediately.  <a href="taskswitch_8c.html#a8951b9dab6452cf831a751d0cda64a5d">More...</a><br /></td></tr>
<tr class="separator:a8951b9dab6452cf831a751d0cda64a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a99ff8bacb9f2f0509b21f45fc7217"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a01a99ff8bacb9f2f0509b21f45fc7217">proc_total</a> ()</td></tr>
<tr class="memdesc:a01a99ff8bacb9f2f0509b21f45fc7217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of running processes.  <a href="taskswitch_8c.html#a01a99ff8bacb9f2f0509b21f45fc7217">More...</a><br /></td></tr>
<tr class="separator:a01a99ff8bacb9f2f0509b21f45fc7217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ea5946e6a5a7a69b87f081ddf0b1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a98ea5946e6a5a7a69b87f081ddf0b1e4">proc_id</a> (int64_t index)</td></tr>
<tr class="memdesc:a98ea5946e6a5a7a69b87f081ddf0b1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PID of a process by index.  <a href="taskswitch_8c.html#a98ea5946e6a5a7a69b87f081ddf0b1e4">More...</a><br /></td></tr>
<tr class="separator:a98ea5946e6a5a7a69b87f081ddf0b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a4cb6343c2ca5228d36287bd60a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#af07a4cb6343c2ca5228d36287bd60a91">proc_run_next</a> ()</td></tr>
<tr class="separator:af07a4cb6343c2ca5228d36287bd60a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e01dc185bad0060a679bb691f0f908"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a52e01dc185bad0060a679bb691f0f908">process_hash</a> (const void *item, uint64_t seed0, uint64_t seed1)</td></tr>
<tr class="separator:a52e01dc185bad0060a679bb691f0f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a5b7697b004c2f36dfd98efc5bee1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a66a5b7697b004c2f36dfd98efc5bee1b">process_compare</a> (const void *<a class="el" href="ahci_8h.html#af4007aacd75b22aee32dba9ea96082c0">a</a>, const void *<a class="el" href="ahci_8h.html#a4313c9563516f94387762ab05763456b">b</a>, void *udata)</td></tr>
<tr class="separator:a66a5b7697b004c2f36dfd98efc5bee1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b299b6b04305ac2665e45ce591204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a891b299b6b04305ac2665e45ce591204">wakeup_callback</a> ([[maybe_unused]] uint8_t isr, [[maybe_unused]] uint64_t errorcode, [[maybe_unused]] uint64_t irq, [[maybe_unused]] void *opaque)</td></tr>
<tr class="separator:a891b299b6b04305ac2665e45ce591204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25d44702b6e10e723714c368c4a7520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#ab25d44702b6e10e723714c368c4a7520">init_process</a> ()</td></tr>
<tr class="memdesc:ab25d44702b6e10e723714c368c4a7520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the process subsystem.  <a href="taskswitch_8c.html#ab25d44702b6e10e723714c368c4a7520">More...</a><br /></td></tr>
<tr class="separator:ab25d44702b6e10e723714c368c4a7520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57a1ba1649626d231502d6c23bbac49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#af57a1ba1649626d231502d6c23bbac49">proc_loop</a> ()</td></tr>
<tr class="memdesc:af57a1ba1649626d231502d6c23bbac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the process scheduling loop.  <a href="taskswitch_8c.html#af57a1ba1649626d231502d6c23bbac49">More...</a><br /></td></tr>
<tr class="separator:af57a1ba1649626d231502d6c23bbac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec64ff3e1bbf088a6611d7304cf72e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a1ec64ff3e1bbf088a6611d7304cf72e2">proc_timer</a> ()</td></tr>
<tr class="memdesc:a1ec64ff3e1bbf088a6611d7304cf72e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to the next scheduled process.  <a href="taskswitch_8c.html#a1ec64ff3e1bbf088a6611d7304cf72e2">More...</a><br /></td></tr>
<tr class="separator:a1ec64ff3e1bbf088a6611d7304cf72e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7844baa5edadb538de03bc3494e947cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a7844baa5edadb538de03bc3494e947cc">proc_ended</a> (<a class="el" href="structprocess__t.html">process_t</a> *proc)</td></tr>
<tr class="memdesc:a7844baa5edadb538de03bc3494e947cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a program has ended.  <a href="taskswitch_8c.html#a7844baa5edadb538de03bc3494e947cc">More...</a><br /></td></tr>
<tr class="separator:a7844baa5edadb538de03bc3494e947cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dd4ffab2aaabd37998ec3b3216af48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#ad2dd4ffab2aaabd37998ec3b3216af48">proc_register_idle</a> (<a class="el" href="taskswitch_8h.html#a82c77e5c902b86503a57e02bb4314bad">proc_idle_timer_t</a> handler, <a class="el" href="taskswitch_8h.html#ab6c8a1a3016b13baf9af7476cceac7d4">idle_type_t</a> <a class="el" href="icmp_8h.html#a1d127017fb298b889f4ba24752d08b8e">type</a>)</td></tr>
<tr class="memdesc:ad2dd4ffab2aaabd37998ec3b3216af48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an idle callback function.  <a href="taskswitch_8c.html#ad2dd4ffab2aaabd37998ec3b3216af48">More...</a><br /></td></tr>
<tr class="separator:ad2dd4ffab2aaabd37998ec3b3216af48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aec02a136f8c68158ceecb321db083fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#aec02a136f8c68158ceecb321db083fe7">proc_current</a> [<a class="el" href="idt_8h.html#a87cbc7cff225b4ad63d67d47c21f933f">MAX_CPUS</a>] = { NULL }</td></tr>
<tr class="memdesc:aec02a136f8c68158ceecb321db083fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently running process on each CPU.  <a href="taskswitch_8c.html#aec02a136f8c68158ceecb321db083fe7">More...</a><br /></td></tr>
<tr class="separator:aec02a136f8c68158ceecb321db083fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f2432ddea8c570469210d4f0813b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a61f2432ddea8c570469210d4f0813b46">proc_list</a> [<a class="el" href="idt_8h.html#a87cbc7cff225b4ad63d67d47c21f933f">MAX_CPUS</a>] = { NULL }</td></tr>
<tr class="memdesc:a61f2432ddea8c570469210d4f0813b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doubly linked list of processes running on each CPU. We store the doubly linked list for fast iteration from one process to the next for the round robin scheduler of processes.  <a href="taskswitch_8c.html#a61f2432ddea8c570469210d4f0813b46">More...</a><br /></td></tr>
<tr class="separator:a61f2432ddea8c570469210d4f0813b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c2d6e299e3e3c2184a6420cd85fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#af39c2d6e299e3e3c2184a6420cd85fbb">combined_proc_list</a> = NULL</td></tr>
<tr class="memdesc:af39c2d6e299e3e3c2184a6420cd85fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined process list for all CPUs.  <a href="taskswitch_8c.html#af39c2d6e299e3e3c2184a6420cd85fbb">More...</a><br /></td></tr>
<tr class="separator:af39c2d6e299e3e3c2184a6420cd85fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95aac4b5cf5e07580b1fcb1fffc5749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinlock_8h.html#af82eed01f0304d83276dda764b213779">spinlock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#ad95aac4b5cf5e07580b1fcb1fffc5749">combined_proc_lock</a> = 0</td></tr>
<tr class="memdesc:ad95aac4b5cf5e07580b1fcb1fffc5749"><td class="mdescLeft">&#160;</td><td class="mdescRight">spinlock to guard the combined list  <a href="taskswitch_8c.html#ad95aac4b5cf5e07580b1fcb1fffc5749">More...</a><br /></td></tr>
<tr class="separator:ad95aac4b5cf5e07580b1fcb1fffc5749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3f41827e667c2d0dcd74dae45051c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spinlock_8h.html#af82eed01f0304d83276dda764b213779">spinlock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#aee3f41827e667c2d0dcd74dae45051c2">proc_lock</a> [<a class="el" href="idt_8h.html#a87cbc7cff225b4ad63d67d47c21f933f">MAX_CPUS</a>] = { 0 }</td></tr>
<tr class="memdesc:aee3f41827e667c2d0dcd74dae45051c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinlocks for each CPU to protect its lists.  <a href="taskswitch_8c.html#aee3f41827e667c2d0dcd74dae45051c2">More...</a><br /></td></tr>
<tr class="separator:aee3f41827e667c2d0dcd74dae45051c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecfe70963a36f1fc74ce7c5f5479e11"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhashmap.html">hashmap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a6ecfe70963a36f1fc74ce7c5f5479e11">process_by_pid</a></td></tr>
<tr class="memdesc:a6ecfe70963a36f1fc74ce7c5f5479e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash map of processes by PID on all CPUs. We use this when we want to find a process by PID (which we do quite often whenever a process waits on another process). This makes it faster to look up a process by PID instead of having to iteate the doubly linked list we use for scheduling.  <a href="taskswitch_8c.html#a6ecfe70963a36f1fc74ce7c5f5479e11">More...</a><br /></td></tr>
<tr class="separator:a6ecfe70963a36f1fc74ce7c5f5479e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98348e79b1c16f9af43ef7e8fc278c22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a98348e79b1c16f9af43ef7e8fc278c22">nextid</a> = 1</td></tr>
<tr class="memdesc:a98348e79b1c16f9af43ef7e8fc278c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next process ID number we will give out for the next process. This increments by one, but will not reuse "holes", so it behaves in a generally posix-like manner.  <a href="taskswitch_8c.html#a98348e79b1c16f9af43ef7e8fc278c22">More...</a><br /></td></tr>
<tr class="separator:a98348e79b1c16f9af43ef7e8fc278c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56fabba3ca96349f6e8cde48042e1b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#aa56fabba3ca96349f6e8cde48042e1b4">process_count</a> = 0</td></tr>
<tr class="memdesc:aa56fabba3ca96349f6e8cde48042e1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter of the number of active processes, we use this to find out how many processes are running and iterate it or decrement it as processes are killed or started so that to find out the total count we do not need to iterate either the hash map or the doubly linked list.  <a href="taskswitch_8c.html#aa56fabba3ca96349f6e8cde48042e1b4">More...</a><br /></td></tr>
<tr class="separator:aa56fabba3ca96349f6e8cde48042e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8461048be5ed2ffb92c3a1fd67759f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structidle__timer__t.html">idle_timer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#a8461048be5ed2ffb92c3a1fd67759f08">task_idles</a> = NULL</td></tr>
<tr class="memdesc:a8461048be5ed2ffb92c3a1fd67759f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists of "idle tasks", idle tasks are simple kernel functions that execute once per cycle around the process loop, used for things that we do not want to put into an interrupt, but still need to run often. timer idles on the other hand are inserted into the LAPIC timer, and need to be written to be friendly within an interrupt context.  <a href="taskswitch_8c.html#a8461048be5ed2ffb92c3a1fd67759f08">More...</a><br /></td></tr>
<tr class="separator:a8461048be5ed2ffb92c3a1fd67759f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac655479725c9e7ef12d2b4ca97b85c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structidle__timer__t.html">idle_timer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#ac655479725c9e7ef12d2b4ca97b85c62">timer_idles</a> = NULL</td></tr>
<tr class="separator:ac655479725c9e7ef12d2b4ca97b85c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83248c0daa174a8ca16df53a7ab8b7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimple__cv__t.html">simple_cv_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="taskswitch_8c.html#ab83248c0daa174a8ca16df53a7ab8b7f">boot_condition</a></td></tr>
<tr class="separator:ab83248c0daa174a8ca16df53a7ab8b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab25d44702b6e10e723714c368c4a7520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25d44702b6e10e723714c368c4a7520">&#9670;&nbsp;</a></span>init_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the process subsystem. </p>

</div>
</div>
<a id="aa8769acde79d259426e68e9e4fba6544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8769acde79d259426e68e9e4fba6544">&#9670;&nbsp;</a></span>proc_cur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess__t.html">process_t</a>* proc_cur </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>logical_cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current process for a logical CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logical_cpu</td><td>CPU ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>process_t* Current process or NULL if none </dd></dl>

</div>
</div>
<a id="a7844baa5edadb538de03bc3494e947cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7844baa5edadb538de03bc3494e947cc">&#9670;&nbsp;</a></span>proc_ended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_ended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a program has ended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Process to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Non-zero if ended, zero otherwise </dd></dl>

</div>
</div>
<a id="ab5a40192ac7fb47cf38c7e803ccd0efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a40192ac7fb47cf38c7e803ccd0efb">&#9670;&nbsp;</a></span>proc_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess__t.html">process_t</a>* proc_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a process by PID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>process_t* Pointer to process detail or NULL if not found </dd></dl>

</div>
</div>
<a id="a949bb14b82e340cdc2a49f9ecc53b086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949bb14b82e340cdc2a49f9ecc53b086">&#9670;&nbsp;</a></span>proc_get_csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* proc_get_csd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98ea5946e6a5a7a69b87f081ddf0b1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ea5946e6a5a7a69b87f081ddf0b1e4">&#9670;&nbsp;</a></span>proc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a> proc_id </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PID of a process by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Process index, between 0 and <a class="el" href="taskswitch_8h.html#a01a99ff8bacb9f2f0509b21f45fc7217" title="Get total number of running processes.">proc_total()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid_t Process ID </dd></dl>

</div>
</div>
<a id="a8951b9dab6452cf831a751d0cda64a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8951b9dab6452cf831a751d0cda64a5d">&#9670;&nbsp;</a></span>proc_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_kill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kill a process immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Process to terminate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b25ff76590322d996a0cb108665cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b25ff76590322d996a0cb108665cedc">&#9670;&nbsp;</a></span>proc_kill_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool proc_kill_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kill a process by PID. </p>
<dl class="section note"><dt>Note</dt><dd>Cannot be used to kill the current process from itself. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Process ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if process found and killed, false otherwise </dd></dl>

</div>
</div>
<a id="aa489f46acde8e80831f0432a1da6e695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa489f46acde8e80831f0432a1da6e695">&#9670;&nbsp;</a></span>proc_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess__t.html">process_t</a>* proc_load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fullpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structconsole.html">console</a> *&#160;</td>
          <td class="paramname"><em>cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a>&#160;</td>
          <td class="paramname"><em>parent_pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>csd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and start a new BASIC process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullpath</td><td>Fully qualified path to file </td></tr>
    <tr><td class="paramname">cons</td><td>Associated console </td></tr>
    <tr><td class="paramname">parent_pid</td><td>Parent PID, or 0 for none </td></tr>
    <tr><td class="paramname">csd</td><td>Current selected directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>process_t* Pointer to new process details </dd></dl>

</div>
</div>
<a id="af57a1ba1649626d231502d6c23bbac49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57a1ba1649626d231502d6c23bbac49">&#9670;&nbsp;</a></span>proc_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the process scheduling loop. </p>
<p>Each logical CPU has its own scheduling loop. </p><dl class="section note"><dt>Note</dt><dd>This function does not return. </dd></dl>

</div>
</div>
<a id="ad2dd4ffab2aaabd37998ec3b3216af48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dd4ffab2aaabd37998ec3b3216af48">&#9670;&nbsp;</a></span>proc_register_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_register_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="taskswitch_8h.html#a82c77e5c902b86503a57e02bb4314bad">proc_idle_timer_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="taskswitch_8h.html#ab6c8a1a3016b13baf9af7476cceac7d4">idle_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an idle callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Function pointer, void(void) </td></tr>
    <tr><td class="paramname">type</td><td>Foreground or background idle type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb94173794194e3382dc5482b7e0aa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb94173794194e3382dc5482b7e0aa62">&#9670;&nbsp;</a></span>proc_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute one atomic BASIC cycle for a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Process to run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af07a4cb6343c2ca5228d36287bd60a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07a4cb6343c2ca5228d36287bd60a91">&#9670;&nbsp;</a></span>proc_run_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_run_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0340f929d97ebceb2e0d7eaa9d4d3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0340f929d97ebceb2e0d7eaa9d4d3ff">&#9670;&nbsp;</a></span>proc_set_csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* proc_set_csd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>csd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the CSD (current selected directory) of a process. </p>
<dl class="section note"><dt>Note</dt><dd>No validation of the path is performed here; external VFS checks must be applied before calling. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Process to update </td></tr>
    <tr><td class="paramname">csd</td><td>New current directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* Updated current directory </dd></dl>

</div>
</div>
<a id="a1ec64ff3e1bbf088a6611d7304cf72e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec64ff3e1bbf088a6611d7304cf72e2">&#9670;&nbsp;</a></span>proc_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_timer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to the next scheduled process. </p>
<p>Implements a round-robin scheduling algorithm. </p>

</div>
</div>
<a id="a01a99ff8bacb9f2f0509b21f45fc7217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a99ff8bacb9f2f0509b21f45fc7217">&#9670;&nbsp;</a></span>proc_total()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t proc_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total number of running processes. </p>
<dl class="section return"><dt>Returns</dt><dd>int64_t Number of running processes </dd></dl>

</div>
</div>
<a id="a8b2b24e480bc2b9188e720c028795cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2b24e480bc2b9188e720c028795cee">&#9670;&nbsp;</a></span>proc_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocess__t.html">process_t</a> *&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="taskswitch_8h.html#a7a26cb7f5678736cec66712d6df1d4ed">pid_t</a>&#160;</td>
          <td class="paramname"><em>otherpid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a process as waiting for another to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Process to mark as waiting </td></tr>
    <tr><td class="paramname">otherpid</td><td>PID to wait on (must exist) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66a5b7697b004c2f36dfd98efc5bee1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a5b7697b004c2f36dfd98efc5bee1b">&#9670;&nbsp;</a></span>process_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_compare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>udata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52e01dc185bad0060a679bb691f0f908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e01dc185bad0060a679bb691f0f908">&#9670;&nbsp;</a></span>process_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t process_hash </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a891b299b6b04305ac2665e45ce591204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891b299b6b04305ac2665e45ce591204">&#9670;&nbsp;</a></span>wakeup_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wakeup_callback </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] uint8_t&#160;</td>
          <td class="paramname"><em>isr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] uint64_t&#160;</td>
          <td class="paramname"><em>errorcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] uint64_t&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab83248c0daa174a8ca16df53a7ab8b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83248c0daa174a8ca16df53a7ab8b7f">&#9670;&nbsp;</a></span>boot_condition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimple__cv__t.html">simple_cv_t</a> boot_condition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af39c2d6e299e3e3c2184a6420cd85fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c2d6e299e3e3c2184a6420cd85fbb">&#9670;&nbsp;</a></span>combined_proc_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess__t.html">process_t</a>* combined_proc_list = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combined process list for all CPUs. </p>

</div>
</div>
<a id="ad95aac4b5cf5e07580b1fcb1fffc5749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95aac4b5cf5e07580b1fcb1fffc5749">&#9670;&nbsp;</a></span>combined_proc_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinlock_8h.html#af82eed01f0304d83276dda764b213779">spinlock_t</a> combined_proc_lock = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spinlock to guard the combined list </p>

</div>
</div>
<a id="a98348e79b1c16f9af43ef7e8fc278c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98348e79b1c16f9af43ef7e8fc278c22">&#9670;&nbsp;</a></span>nextid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nextid = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next process ID number we will give out for the next process. This increments by one, but will not reuse "holes", so it behaves in a generally posix-like manner. </p>

</div>
</div>
<a id="aec02a136f8c68158ceecb321db083fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec02a136f8c68158ceecb321db083fe7">&#9670;&nbsp;</a></span>proc_current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess__t.html">process_t</a>* proc_current[<a class="el" href="idt_8h.html#a87cbc7cff225b4ad63d67d47c21f933f">MAX_CPUS</a>] = { NULL }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The currently running process on each CPU. </p>

</div>
</div>
<a id="a61f2432ddea8c570469210d4f0813b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f2432ddea8c570469210d4f0813b46">&#9670;&nbsp;</a></span>proc_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocess__t.html">process_t</a>* proc_list[<a class="el" href="idt_8h.html#a87cbc7cff225b4ad63d67d47c21f933f">MAX_CPUS</a>] = { NULL }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Doubly linked list of processes running on each CPU. We store the doubly linked list for fast iteration from one process to the next for the round robin scheduler of processes. </p>

</div>
</div>
<a id="aee3f41827e667c2d0dcd74dae45051c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3f41827e667c2d0dcd74dae45051c2">&#9670;&nbsp;</a></span>proc_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spinlock_8h.html#af82eed01f0304d83276dda764b213779">spinlock_t</a> proc_lock[<a class="el" href="idt_8h.html#a87cbc7cff225b4ad63d67d47c21f933f">MAX_CPUS</a>] = { 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spinlocks for each CPU to protect its lists. </p>

</div>
</div>
<a id="a6ecfe70963a36f1fc74ce7c5f5479e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecfe70963a36f1fc74ce7c5f5479e11">&#9670;&nbsp;</a></span>process_by_pid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhashmap.html">hashmap</a>* process_by_pid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A hash map of processes by PID on all CPUs. We use this when we want to find a process by PID (which we do quite often whenever a process waits on another process). This makes it faster to look up a process by PID instead of having to iteate the doubly linked list we use for scheduling. </p>

</div>
</div>
<a id="aa56fabba3ca96349f6e8cde48042e1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56fabba3ca96349f6e8cde48042e1b4">&#9670;&nbsp;</a></span>process_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t process_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A counter of the number of active processes, we use this to find out how many processes are running and iterate it or decrement it as processes are killed or started so that to find out the total count we do not need to iterate either the hash map or the doubly linked list. </p>

</div>
</div>
<a id="a8461048be5ed2ffb92c3a1fd67759f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8461048be5ed2ffb92c3a1fd67759f08">&#9670;&nbsp;</a></span>task_idles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structidle__timer__t.html">idle_timer_t</a>* task_idles = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists of "idle tasks", idle tasks are simple kernel functions that execute once per cycle around the process loop, used for things that we do not want to put into an interrupt, but still need to run often. timer idles on the other hand are inserted into the LAPIC timer, and need to be written to be friendly within an interrupt context. </p>

</div>
</div>
<a id="ac655479725c9e7ef12d2b4ca97b85c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac655479725c9e7ef12d2b4ca97b85c62">&#9670;&nbsp;</a></span>timer_idles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structidle__timer__t.html">idle_timer_t</a> * timer_idles = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="taskswitch_8c.html">taskswitch.c</a></li>
    <li class="footer">Generated on Tue Aug 5 2025 05:31:12 for Retro Rocket Kernel by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
