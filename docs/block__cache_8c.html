<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Retro Rocket OS: src/fs/block_cache.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Retro Rocket OS
   </div>
   <div id="projectbrief">BASIC-Powered Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('block__cache_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">block_cache.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>O(1) block cache with LRU eviction.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="kernel_8h.html">kernel.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="buddy__allocator_8h.html">buddy_allocator.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblock__cache__entry__t.html">block_cache_entry_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single cached sector entry.  <a href="structblock__cache__entry__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlru__node__t.html">lru_node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblock__cache__t.html">block_cache_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-device block cache.  <a href="structblock__cache__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aea971ff5ce2f01ec752eef62aa6f9a2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#aea971ff5ce2f01ec752eef62aa6f9a2b">BLOCK_CACHE_SECTOR_CAP</a>&#160;&#160;&#160;8192</td></tr>
<tr class="memdesc:aea971ff5ce2f01ec752eef62aa6f9a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global per-device cache capacity in sectors.  <a href="block__cache_8c.html#aea971ff5ce2f01ec752eef62aa6f9a2b">More...</a><br /></td></tr>
<tr class="separator:aea971ff5ce2f01ec752eef62aa6f9a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817b14615a4484f6c112ea80aed1e34e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a817b14615a4484f6c112ea80aed1e34e">CACHE_HASH_SEED0</a>&#160;&#160;&#160;1469598103934665603ULL</td></tr>
<tr class="separator:a817b14615a4484f6c112ea80aed1e34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd47563d0796c2c7a4dba8ae092bb1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a5dd47563d0796c2c7a4dba8ae092bb1e">CACHE_HASH_SEED1</a>&#160;&#160;&#160;1099511628211ULL</td></tr>
<tr class="separator:a5dd47563d0796c2c7a4dba8ae092bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4b1a3ccd1b810237992eb26829b2e19"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#ac4b1a3ccd1b810237992eb26829b2e19">cache_compare</a> (const void *a, const void *b, [[maybe_unused]] void *udata)</td></tr>
<tr class="memdesc:ac4b1a3ccd1b810237992eb26829b2e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two cache entries by LBA (hashmap comparator).  <a href="block__cache_8c.html#ac4b1a3ccd1b810237992eb26829b2e19">More...</a><br /></td></tr>
<tr class="separator:ac4b1a3ccd1b810237992eb26829b2e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0efe341a694706cdfaacce6c2ca56c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#abe0efe341a694706cdfaacce6c2ca56c">cache_hash</a> (const void *item, uint64_t seed0, uint64_t seed1)</td></tr>
<tr class="memdesc:abe0efe341a694706cdfaacce6c2ca56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash a cache entry by LBA (hashmap hasher).  <a href="block__cache_8c.html#abe0efe341a694706cdfaacce6c2ca56c">More...</a><br /></td></tr>
<tr class="separator:abe0efe341a694706cdfaacce6c2ca56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4942023a165e6903d9c628c3f806c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlru__node__t.html">lru_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#aea4942023a165e6903d9c628c3f806c2">lru_alloc_node</a> (uint64_t lba)</td></tr>
<tr class="separator:aea4942023a165e6903d9c628c3f806c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289bc1117f84204d9c3d793e43883619"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a289bc1117f84204d9c3d793e43883619">lru_free_node</a> (<a class="el" href="structlru__node__t.html">lru_node_t</a> *n)</td></tr>
<tr class="separator:a289bc1117f84204d9c3d793e43883619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed89ec1e1b4f49c804a29fdfba5252fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#aed89ec1e1b4f49c804a29fdfba5252fc">lru_unlink</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>, <a class="el" href="structlru__node__t.html">lru_node_t</a> *n)</td></tr>
<tr class="separator:aed89ec1e1b4f49c804a29fdfba5252fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3617dc7e13e781b8122cf426fc8f18"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a3e3617dc7e13e781b8122cf426fc8f18">lru_touch</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>, uint64_t lba)</td></tr>
<tr class="separator:a3e3617dc7e13e781b8122cf426fc8f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad661aba7b7732d552d620b180b611fe3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlru__node__t.html">lru_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#ad661aba7b7732d552d620b180b611fe3">lru_pop_head</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>)</td></tr>
<tr class="separator:ad661aba7b7732d552d620b180b611fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84954ff10eddc8abff7aab7087012c88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a84954ff10eddc8abff7aab7087012c88">evict_one</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>)</td></tr>
<tr class="memdesc:a84954ff10eddc8abff7aab7087012c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict the globally oldest entry from the cache.  <a href="block__cache_8c.html#a84954ff10eddc8abff7aab7087012c88">More...</a><br /></td></tr>
<tr class="separator:a84954ff10eddc8abff7aab7087012c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d33a0b1b6d92c809064141ee29e848"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a48d33a0b1b6d92c809064141ee29e848">cache_malloc</a> (size_t <a class="el" href="fat32_8h.html#ab2c6b258f02add8fdf4cfc7c371dd772">size</a>, void *udata)</td></tr>
<tr class="separator:a48d33a0b1b6d92c809064141ee29e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203ee3b15cac3c0acc1b07515c4e079f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a203ee3b15cac3c0acc1b07515c4e079f">cache_realloc</a> (void *ptr, size_t <a class="el" href="fat32_8h.html#ab2c6b258f02add8fdf4cfc7c371dd772">size</a>, void *udata)</td></tr>
<tr class="separator:a203ee3b15cac3c0acc1b07515c4e079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb6b42078d74218c121ea0d3e0d0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#abbfb6b42078d74218c121ea0d3e0d0ed">cache_free</a> (const void *ptr, void *udata)</td></tr>
<tr class="separator:abbfb6b42078d74218c121ea0d3e0d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e91ba9289f42c4b1de6f95b05855a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a38e91ba9289f42c4b1de6f95b05855a9">block_cache_create</a> (<a class="el" href="structstorage__device__t.html">storage_device_t</a> *dev)</td></tr>
<tr class="memdesc:a38e91ba9289f42c4b1de6f95b05855a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new cache for a storage device.  <a href="block__cache_8c.html#a38e91ba9289f42c4b1de6f95b05855a9">More...</a><br /></td></tr>
<tr class="separator:a38e91ba9289f42c4b1de6f95b05855a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe62fb75908c192e86197b4def8cb84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#abfe62fb75908c192e86197b4def8cb84">block_cache_destroy</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> **pcache)</td></tr>
<tr class="memdesc:abfe62fb75908c192e86197b4def8cb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a cache and free all associated resources.  <a href="block__cache_8c.html#abfe62fb75908c192e86197b4def8cb84">More...</a><br /></td></tr>
<tr class="separator:abfe62fb75908c192e86197b4def8cb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2359288ab07f2d82c900200a0dd9897f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a2359288ab07f2d82c900200a0dd9897f">sectors_for_len</a> (uint32_t sector_size, uint32_t bytes)</td></tr>
<tr class="memdesc:a2359288ab07f2d82c900200a0dd9897f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a sector count that covers a byte length.  <a href="block__cache_8c.html#a2359288ab07f2d82c900200a0dd9897f">More...</a><br /></td></tr>
<tr class="separator:a2359288ab07f2d82c900200a0dd9897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8884125c6b7df9ca2fd819bbd9138b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a3b8884125c6b7df9ca2fd819bbd9138b">block_cache_read</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>, uint64_t lba, uint32_t bytes, unsigned char *out)</td></tr>
<tr class="memdesc:a3b8884125c6b7df9ca2fd819bbd9138b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a cached device.  <a href="block__cache_8c.html#a3b8884125c6b7df9ca2fd819bbd9138b">More...</a><br /></td></tr>
<tr class="separator:a3b8884125c6b7df9ca2fd819bbd9138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf875ca742effa3fcbdb8d204802361"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#acaf875ca742effa3fcbdb8d204802361">block_cache_write</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>, uint64_t lba, uint32_t bytes, const unsigned char *<a class="el" href="tcp_8h.html#a0d6d2cdb1162c6355e40ab772fa5debc">src</a>)</td></tr>
<tr class="memdesc:acaf875ca742effa3fcbdb8d204802361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes through to a cached device.  <a href="block__cache_8c.html#acaf875ca742effa3fcbdb8d204802361">More...</a><br /></td></tr>
<tr class="separator:acaf875ca742effa3fcbdb8d204802361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9155c768b2392e61187abca5dc8e6134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#a9155c768b2392e61187abca5dc8e6134">block_cache_invalidate</a> (<a class="el" href="structblock__cache__t.html">block_cache_t</a> *<a class="el" href="serial_8h.html#adc08ed1554f35803d229aeaf11216b3f">c</a>)</td></tr>
<tr class="memdesc:a9155c768b2392e61187abca5dc8e6134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all entries in a cache.  <a href="block__cache_8c.html#a9155c768b2392e61187abca5dc8e6134">More...</a><br /></td></tr>
<tr class="separator:a9155c768b2392e61187abca5dc8e6134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abfa0a4082b12c96cee5796898d6d7b41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuddy__allocator__t.html">buddy_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__cache_8c.html#abfa0a4082b12c96cee5796898d6d7b41">cache_allocator</a> = {}</td></tr>
<tr class="separator:abfa0a4082b12c96cee5796898d6d7b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>O(1) block cache with LRU eviction. </p>
<p>This module implements a sector/block cache designed for use with storage devices. It combines a hashmap (for direct lookup) with an LRU queue (for eviction ordering).</p>
<h2><a class="anchor" id="autotoc_md674"></a>
Design</h2>
<ul>
<li>Each cached LBA is stored in a hashmap for O(1) lookup.</li>
<li>The eviction policy is Least Recently Used (LRU).</li>
<li>Instead of maintaining a "perfect" LRU list, the queue only stores LBA values. When an LBA is re-inserted, a new entry is appended to the tail of the list; the old entry is left in place. On eviction, the cache checks if the LBA still exists in the hashmap before removing it.</li>
</ul>
<h2><a class="anchor" id="autotoc_md675"></a>
Complexity</h2>
<ul>
<li>Cache store (insert): O(1)</li>
<li>Cache fetch (lookup): O(1)</li>
<li>Eviction: O(1) amortised</li>
</ul>
<p>By tolerating duplicates in the LRU queue and validating at eviction time, we avoid costly O(n) operations to move entries within the queue. The result is a strictly constant-time cache for both reads and writes.</p>
<h2><a class="anchor" id="autotoc_md676"></a>
Trade-offs</h2>
<ul>
<li>Memory overhead: The LRU queue may contain duplicate LBAs. This increases memory use slightly, but only linearly with cache size.</li>
<li>Eviction precision: Because of duplicates, eviction order is approximate LRU rather than perfect. In practice this has negligible impact on hit rates and avoids the cost of O(n) list traversal or heap reordering.</li>
</ul>
<h2><a class="anchor" id="autotoc_md677"></a>
Summary</h2>
<p>This design achieves the optimal theoretical complexity for a block cache: O(1) lookup, O(1) insert, and O(1) eviction. It is robust against pointer invalidation bugs by never storing raw pointers from the hashmap in the LRU queue, and it guarantees bounded, predictable performance even under heavy load. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aea971ff5ce2f01ec752eef62aa6f9a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea971ff5ce2f01ec752eef62aa6f9a2b">&#9670;&nbsp;</a></span>BLOCK_CACHE_SECTOR_CAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLOCK_CACHE_SECTOR_CAP&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global per-device cache capacity in sectors. </p>
<p>This limit is applied to every cache instance. Increase with care; it impacts memory consumption linearly (one sector buffer per entry). </p>

</div>
</div>
<a id="a817b14615a4484f6c112ea80aed1e34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817b14615a4484f6c112ea80aed1e34e">&#9670;&nbsp;</a></span>CACHE_HASH_SEED0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_HASH_SEED0&#160;&#160;&#160;1469598103934665603ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dd47563d0796c2c7a4dba8ae092bb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd47563d0796c2c7a4dba8ae092bb1e">&#9670;&nbsp;</a></span>CACHE_HASH_SEED1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_HASH_SEED1&#160;&#160;&#160;1099511628211ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a38e91ba9289f42c4b1de6f95b05855a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e91ba9289f42c4b1de6f95b05855a9">&#9670;&nbsp;</a></span>block_cache_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structblock__cache__t.html">block_cache_t</a>* block_cache_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstorage__device__t.html">storage_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new cache for a storage device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Device to attach cache to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to cache instance, or NULL on error. </dd></dl>

</div>
</div>
<a id="abfe62fb75908c192e86197b4def8cb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe62fb75908c192e86197b4def8cb84">&#9670;&nbsp;</a></span>block_cache_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void block_cache_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> **&#160;</td>
          <td class="paramname"><em>pcache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a cache and free all associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcache</td><td>Pointer to cache pointer; set to NULL on return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9155c768b2392e61187abca5dc8e6134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9155c768b2392e61187abca5dc8e6134">&#9670;&nbsp;</a></span>block_cache_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void block_cache_invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate all entries in a cache. </p>
<p>Useful when a device is reset or forcibly changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Cache instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b8884125c6b7df9ca2fd819bbd9138b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8884125c6b7df9ca2fd819bbd9138b">&#9670;&nbsp;</a></span>block_cache_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int block_cache_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from a cached device. </p>
<p>Granularity is per sector; the cache works in multiples of the deviceâ€™s block size. Reads hitting the cache are served immediately; misses are read from the device and then cached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Cache instance. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting sector number. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramname">out</td><td>Destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (<a class="el" href="filesystem_8h.html#a59cfed9fdbdd4476b57fdf0a163e0a48">fs_set_error()</a> is set). </dd></dl>

</div>
</div>
<a id="acaf875ca742effa3fcbdb8d204802361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf875ca742effa3fcbdb8d204802361">&#9670;&nbsp;</a></span>block_cache_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int block_cache_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes through to a cached device. </p>
<p>Writes are always passed to the device. The cache is updated (write-allocate) so subsequent reads will hit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Cache instance. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting sector number. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to write. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure (<a class="el" href="filesystem_8h.html#a59cfed9fdbdd4476b57fdf0a163e0a48">fs_set_error()</a> is set). </dd></dl>

</div>
</div>
<a id="ac4b1a3ccd1b810237992eb26829b2e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b1a3ccd1b810237992eb26829b2e19">&#9670;&nbsp;</a></span>cache_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cache_compare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] void *&#160;</td>
          <td class="paramname"><em>udata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two cache entries by LBA (hashmap comparator). </p>
<p>Expects pointers to <a class="el" href="structblock__cache__entry__t.html">block_cache_entry_t</a>. Returns negative, zero, or positive according to standard qsort-style ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First entry. </td></tr>
    <tr><td class="paramname">b</td><td>Second entry. </td></tr>
    <tr><td class="paramname">udata</td><td>Unused user data pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if <code>a</code> &lt; <code>b</code>, 0 if equal, &gt;0 if <code>a</code> &gt; <code>b</code>. </dd></dl>

</div>
</div>
<a id="abbfb6b42078d74218c121ea0d3e0d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfb6b42078d74218c121ea0d3e0d0ed">&#9670;&nbsp;</a></span>cache_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cache_free </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>udata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe0efe341a694706cdfaacce6c2ca56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0efe341a694706cdfaacce6c2ca56c">&#9670;&nbsp;</a></span>cache_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cache_hash </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash a cache entry by LBA (hashmap hasher). </p>
<p>Uses SipHash over the 64-bit LBA stored in the entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Entry to hash (points to <a class="el" href="structblock__cache__entry__t.html">block_cache_entry_t</a>). </td></tr>
    <tr><td class="paramname">seed0</td><td>Primary seed. </td></tr>
    <tr><td class="paramname">seed1</td><td>Secondary seed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit hash value. </dd></dl>

</div>
</div>
<a id="a48d33a0b1b6d92c809064141ee29e848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d33a0b1b6d92c809064141ee29e848">&#9670;&nbsp;</a></span>cache_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cache_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>udata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a203ee3b15cac3c0acc1b07515c4e079f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203ee3b15cac3c0acc1b07515c4e079f">&#9670;&nbsp;</a></span>cache_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cache_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>udata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84954ff10eddc8abff7aab7087012c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84954ff10eddc8abff7aab7087012c88">&#9670;&nbsp;</a></span>evict_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evict_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evict the globally oldest entry from the cache. </p>
<p>Pops the LRU head, removes the entry from the hashmap if present, and frees its sector buffer. No-op if the LRU is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Cache instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea4942023a165e6903d9c628c3f806c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4942023a165e6903d9c628c3f806c2">&#9670;&nbsp;</a></span>lru_alloc_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlru__node__t.html">lru_node_t</a>* lru_alloc_node </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a289bc1117f84204d9c3d793e43883619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289bc1117f84204d9c3d793e43883619">&#9670;&nbsp;</a></span>lru_free_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lru_free_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlru__node__t.html">lru_node_t</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad661aba7b7732d552d620b180b611fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad661aba7b7732d552d620b180b611fe3">&#9670;&nbsp;</a></span>lru_pop_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlru__node__t.html">lru_node_t</a>* lru_pop_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e3617dc7e13e781b8122cf426fc8f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3617dc7e13e781b8122cf426fc8f18">&#9670;&nbsp;</a></span>lru_touch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lru_touch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed89ec1e1b4f49c804a29fdfba5252fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed89ec1e1b4f49c804a29fdfba5252fc">&#9670;&nbsp;</a></span>lru_unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lru_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structblock__cache__t.html">block_cache_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlru__node__t.html">lru_node_t</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2359288ab07f2d82c900200a0dd9897f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2359288ab07f2d82c900200a0dd9897f">&#9670;&nbsp;</a></span>sectors_for_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sectors_for_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sector_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a sector count that covers a byte length. </p>
<p>Rounds up <code>bytes</code> to a whole number of <code>sector_size</code> units. Used to iterate multi-sector operations at sector granularity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector_size</td><td>Device sector size in bytes. </td></tr>
    <tr><td class="paramname">bytes</td><td>Requested byte length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sectors covering <code>bytes</code> (at least 1). </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abfa0a4082b12c96cee5796898d6d7b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa0a4082b12c96cee5796898d6d7b41">&#9670;&nbsp;</a></span>cache_allocator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuddy__allocator__t.html">buddy_allocator_t</a> cache_allocator = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Buddy allocator for content </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7d71b6c457a61cbf03a04bfdc57b6110.html">fs</a></li><li class="navelem"><a class="el" href="block__cache_8c.html">block_cache.c</a></li>
    <li class="footer">Generated on Sat Sep 6 2025 02:14:10 for Retro Rocket OS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
